"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __importStar(require("./index"));
var testHelpers_1 = require("./utils/testHelpers");
var types_1 = require("./types");
var resolution;
beforeEach(function () {
    jest.restoreAllMocks();
    resolution = new index_1.default();
});
describe('ZNS', function () {
    describe('.NormalizeSource', function () {
        it('checks normalizeSource zns (boolean)', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(resolution.zns.network).toBe('mainnet');
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (boolean - false)', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({ blockchain: { zns: false } });
                expect(resolution.zns).toBeUndefined();
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (string)', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(resolution.zns.network).toBe('mainnet');
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns wrong string', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(function () { return new index_1.default({ blockchain: { zns: 'https://wrongurl.com' } }); }).toThrowError('Unspecified network in Resolution ZNS configuration');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #1', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: { zns: { url: 'https://api.zilliqa.com' } },
                });
                expect(resolution.zns.network).toBe('mainnet');
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #2', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: { zns: { network: 333 } },
                });
                expect(resolution.zns.url).toBe('https://dev-api.zilliqa.com');
                expect(resolution.zns.network).toBe('testnet');
                expect(resolution.zns.registryAddress).toBeUndefined();
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #3', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: { zns: { url: 'https://api.zilliqa.com' } },
                });
                expect(resolution.zns.network).toBe('mainnet');
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #4', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: { zns: { url: 'https://api.zilliqa.com', network: 1 } },
                });
                expect(resolution.zns.network).toBe('mainnet');
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #5', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: { zns: { url: 'https://api.zilliqa.com', network: 333 } },
                });
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                expect(resolution.zns.network).toBe('testnet');
                expect(resolution.zns.registryAddress).toBeUndefined();
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #6', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(function () { return new index_1.default({ blockchain: { zns: { network: 42 } } }); }).toThrowError('Unspecified network in Resolution ZNS configuration');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #7', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(function () { return new index_1.default({ blockchain: { zns: { network: 'invalid' } } }); }).toThrowError('Unspecified url in Resolution ZNS configuration');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #8', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: { zns: { network: 'mainnet' } },
                });
                expect(resolution.zns.network).toBe('mainnet');
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #9', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: { zns: { network: 'testnet' } },
                });
                expect(resolution.zns.network).toBe('testnet');
                expect(resolution.zns.url).toBe('https://dev-api.zilliqa.com');
                expect(resolution.zns.registryAddress).toBeUndefined();
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #10', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: {
                        zns: { registry: 'zil1jcgu2wlx6xejqk9jw3aaankw6lsjzeunx2j0jz' },
                    },
                });
                expect(resolution.zns.network).toBe('mainnet');
                expect(resolution.zns.registryAddress).toBe('zil1jcgu2wlx6xejqk9jw3aaankw6lsjzeunx2j0jz');
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                return [2 /*return*/];
            });
        }); });
        it('checks normalizeSource zns (object) #11', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution;
            return __generator(this, function (_a) {
                resolution = new index_1.default({
                    blockchain: {
                        zns: { registry: '0xabcffff1231586348194fcabbeff1231240234fc' },
                    },
                });
                expect(resolution.zns.network).toBe('mainnet');
                expect(resolution.zns.url).toBe('https://api.zilliqa.com');
                expect(resolution.zns.registryAddress).toBe('zil1408llufrzkrrfqv5lj4malcjxyjqyd8urd7xz6');
                return [2 /*return*/];
            });
        }); });
    });
    describe('.Resolve', function () {
        it('resolves .zil name using blockchain', function () { return __awaiter(void 0, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        testHelpers_1.mockAPICalls('zil_using_blockchain', testHelpers_1.ZilliqaUrl);
                        return [4 /*yield*/, resolution.resolve('cofounding.zil')];
                    case 1:
                        result = _a.sent();
                        expect(result).toBeDefined();
                        expect(result.addresses.ETH).toEqual('0xaa91734f90795e80751c96e682a321bb3c1a4186');
                        expect(result.meta.owner).toEqual('zil1ye72zl5t8wl5n3f2fsa5w0x7hja0jqj7mhct23');
                        expect(result.meta.type).toEqual('ZNS');
                        expect(result.meta.ttl).toEqual(0);
                        return [2 /*return*/];
                }
            });
        }); });
        it('resolves unclaimed domain using blockchain', function () { return __awaiter(void 0, void 0, void 0, function () {
            var spyes, address, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        spyes = testHelpers_1.mockAsyncMethods(resolution.zns, {
                            getRecordsAddresses: undefined,
                        });
                        return [4 /*yield*/, resolution.address('test.zil', 'ETH')];
                    case 1:
                        address = _b.sent();
                        testHelpers_1.expectSpyToBeCalled(spyes);
                        expect(address).toEqual(null);
                        _a = expect;
                        return [4 /*yield*/, resolution.owner('test.zil')];
                    case 2:
                        _a.apply(void 0, [_b.sent()]).toEqual(null);
                        return [2 /*return*/];
                }
            });
        }); });
        it('resolves domain using blockchain #2', function () { return __awaiter(void 0, void 0, void 0, function () {
            var spyes, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spyes = testHelpers_1.mockAsyncMethods(resolution.zns, {
                            getRecordsAddresses: [
                                'zil1zzpjwyp2nu29pcv3sh04qxq9x5l45vke0hrwec',
                                '0x3f329078d95f043fd902d5c3ea2fbce0b3fca003',
                            ],
                            getResolverRecords: {
                                'crypto.BURST.address': 'BURST-R7KK-SBSY-FENX-AWYMW',
                                'crypto.ZIL.address': 'zil1zzpjwyp2nu29pcv3sh04qxq9x5l45vke0hrwes',
                                'ipfs.html.value': 'mtwirsqawjuoloq2gvtyug2tc3jbf5htm2zeo4rsknfiv3fdp46a',
                                'whois.email.value': 'rleinbox@gmail.com',
                                'whois.for_sale.value': 'true',
                            },
                        });
                        return [4 /*yield*/, resolution.resolve('test-manage-one.zil')];
                    case 1:
                        result = _a.sent();
                        testHelpers_1.expectSpyToBeCalled(spyes);
                        expect(result.addresses).toEqual({
                            BURST: 'BURST-R7KK-SBSY-FENX-AWYMW',
                            ZIL: 'zil1zzpjwyp2nu29pcv3sh04qxq9x5l45vke0hrwes',
                        });
                        expect(result.meta).toEqual({
                            owner: 'zil1zzpjwyp2nu29pcv3sh04qxq9x5l45vke0hrwec',
                            type: 'ZNS',
                            ttl: 0,
                        });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should resolve with Resolution key setuped', function () { return __awaiter(void 0, void 0, void 0, function () {
            var eye, secondEye, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        eye = testHelpers_1.mockAsyncMethod(resolution.zns, 'getRecordsAddresses', [
                            'zil194qcjskuuxh6qtg8xw3qqrr3kdc6dtq8ct6j9s',
                            '0xdac22230adfe4601f00631eae92df6d77f054891',
                        ]);
                        secondEye = testHelpers_1.mockAsyncMethod(resolution.zns, 'getResolverRecords', {
                            'crypto.BCH.address': 'qrq4sk49ayvepqz7j7ep8x4km2qp8lauvcnzhveyu6',
                            'crypto.BTC.address': '1EVt92qQnaLDcmVFtHivRJaunG2mf2C3mB',
                            'crypto.DASH.address': 'XnixreEBqFuSLnDSLNbfqMH1GsZk7cgW4j',
                            'crypto.ETH.address': '0x45b31e01AA6f42F0549aD482BE81635ED3149abb',
                            'crypto.LTC.address': 'LetmswTW3b7dgJ46mXuiXMUY17XbK29UmL',
                            'crypto.XMR.address': '447d7TVFkoQ57k3jm3wGKoEAkfEym59mK96Xw5yWamDNFGaLKW5wL2qK5RMTDKGSvYfQYVN7dLSrLdkwtKH3hwbSCQCu26d',
                            'crypto.ZEC.address': 't1h7ttmQvWCSH1wfrcmvT4mZJfGw2DgCSqV',
                            'crypto.ZIL.address': 'zil1yu5u4hegy9v3xgluweg4en54zm8f8auwxu0xxj',
                            'ipfs.html.value': 'QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHuK',
                            'ipfs.redirect_domain.value': 'www.unstoppabledomains.com',
                        });
                        return [4 /*yield*/, resolution.zns.Resolution('brad.zil')];
                    case 1:
                        result = _a.sent();
                        testHelpers_1.expectSpyToBeCalled([eye, secondEye]);
                        expect(result).toEqual({
                            crypto: {
                                BCH: { address: 'qrq4sk49ayvepqz7j7ep8x4km2qp8lauvcnzhveyu6' },
                                BTC: { address: '1EVt92qQnaLDcmVFtHivRJaunG2mf2C3mB' },
                                DASH: { address: 'XnixreEBqFuSLnDSLNbfqMH1GsZk7cgW4j' },
                                ETH: { address: '0x45b31e01AA6f42F0549aD482BE81635ED3149abb' },
                                LTC: { address: 'LetmswTW3b7dgJ46mXuiXMUY17XbK29UmL' },
                                XMR: {
                                    address: '447d7TVFkoQ57k3jm3wGKoEAkfEym59mK96Xw5yWamDNFGaLKW5wL2qK5RMTDKGSvYfQYVN7dLSrLdkwtKH3hwbSCQCu26d',
                                },
                                ZEC: { address: 't1h7ttmQvWCSH1wfrcmvT4mZJfGw2DgCSqV' },
                                ZIL: { address: 'zil1yu5u4hegy9v3xgluweg4en54zm8f8auwxu0xxj' },
                            },
                            ipfs: {
                                html: { value: 'QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHuK' },
                                redirect_domain: { value: 'www.unstoppabledomains.com' },
                            },
                        });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should resolve with Resolution key setuped #2', function () { return __awaiter(void 0, void 0, void 0, function () {
            var eye, secondEye, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        eye = testHelpers_1.mockAsyncMethod(resolution.zns, 'getRecordsAddresses', [
                            'zil1f6vyj5hgvll3xtx5kuxd8ucn66x9zxmkp34agy',
                            '0xa9b1d3647e4deb9ce4e601c2c9e0a2fdf2d7415a',
                        ]);
                        secondEye = testHelpers_1.mockAsyncMethod(resolution.zns, 'getResolverRecords', {
                            'ipfs.html.hash': 'QmefehFs5n8yQcGCVJnBMY3Hr6aMRHtsoniAhsM1KsHMSe',
                            'ipfs.html.value': 'QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHu',
                            'ipfs.redirect_domain.value': 'www.unstoppabledomains.com',
                            'whois.email.value': 'matt+test@unstoppabledomains.com',
                            'whois.for_sale.value': 'true',
                        });
                        return [4 /*yield*/, resolution.zns.Resolution('ergergergerg.zil')];
                    case 1:
                        result = _a.sent();
                        testHelpers_1.expectSpyToBeCalled([eye, secondEye]);
                        expect(result).toEqual({
                            ipfs: {
                                html: {
                                    hash: 'QmefehFs5n8yQcGCVJnBMY3Hr6aMRHtsoniAhsM1KsHMSe',
                                    value: 'QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHu',
                                },
                                redirect_domain: { value: 'www.unstoppabledomains.com' },
                            },
                            whois: {
                                email: { value: 'matt+test@unstoppabledomains.com' },
                                for_sale: { value: 'true' },
                            },
                        });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should resolve with Resolution key setuped #3', function () { return __awaiter(void 0, void 0, void 0, function () {
            var zns, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        zns = resolution.zns;
                        expect(zns).toBeDefined();
                        return [4 /*yield*/, zns.Resolution('invalid.domain')];
                    case 1:
                        result = _a.sent();
                        expect(result).toEqual({});
                        return [2 /*return*/];
                }
            });
        }); });
        it('should resolve with Resolution key setuped #4', function () { return __awaiter(void 0, void 0, void 0, function () {
            var zns, spies, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        zns = resolution.zns;
                        spies = testHelpers_1.mockAsyncMethods(zns, {
                            getRecordsAddresses: [
                                'zil1tqcrcg50emead2pp6p37p0hnupkswpnlwpnm3r',
                                '0x6aec0e4bb2c6fa4acacdaa3f3d871db5e2e1c0ea',
                            ],
                            getContractField: {
                                'crypto.BTC.address': '17LV6fxL8b1pJomn5zoDR3ZCnbt88ehGBf',
                                'crypto.ETH.address': '0x0ed6180ef7c638064b9b17ff53ba76ec7077dd95',
                                'crypto.LTC.address': 'MTbeoMfWqEZaaZVG1yE1ENoxVGNmMAxoEj',
                                'whois.email.value': 'jordanb_970@hotmail.com',
                                'whois.for_sale.value': 'true',
                            },
                        });
                        expect(zns).toBeDefined();
                        return [4 /*yield*/, zns.Resolution('mcafee2020.zil')];
                    case 1:
                        result = _a.sent();
                        testHelpers_1.expectSpyToBeCalled(spies);
                        expect(result).toEqual({
                            crypto: {
                                BTC: { address: '17LV6fxL8b1pJomn5zoDR3ZCnbt88ehGBf' },
                                ETH: { address: '0x0ed6180ef7c638064b9b17ff53ba76ec7077dd95' },
                                LTC: { address: 'MTbeoMfWqEZaaZVG1yE1ENoxVGNmMAxoEj' },
                            },
                            whois: {
                                email: { value: 'jordanb_970@hotmail.com' },
                                for_sale: { value: 'true' },
                            },
                        });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should return a valid resolver address', function () { return __awaiter(void 0, void 0, void 0, function () {
            var spies, resolverAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spies = testHelpers_1.mockAsyncMethods(resolution.zns, {
                            getRecordsAddresses: [
                                'zil194qcjskuuxh6qtg8xw3qqrr3kdc6dtq8ct6j9s',
                                '0xdac22230adfe4601f00631eae92df6d77f054891',
                            ],
                        });
                        return [4 /*yield*/, resolution.zns.resolver('brad.zil')];
                    case 1:
                        resolverAddress = _a.sent();
                        testHelpers_1.expectSpyToBeCalled(spies);
                        expect(resolverAddress).toBe('0xdac22230adfe4601f00631eae92df6d77f054891');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should not find a resolverAddress', function () { return __awaiter(void 0, void 0, void 0, function () {
            var spies;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spies = testHelpers_1.mockAsyncMethods(resolution.zns, {
                            getRecordsAddresses: undefined,
                        });
                        return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(resolution.zns.resolver('sopmethingveryweirdthatnoonewilltakeever.zil'), index_1.ResolutionErrorCode.UnregisteredDomain)];
                    case 1:
                        _a.sent();
                        testHelpers_1.expectSpyToBeCalled(spies);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should have a zero resolver hahaha', function () { return __awaiter(void 0, void 0, void 0, function () {
            var spies;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spies = testHelpers_1.mockAsyncMethods(resolution.zns, {
                            getRecordsAddresses: [
                                'zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz',
                                types_1.NullAddress[1],
                            ],
                        });
                        return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(resolution.zns.resolver('uihui12d.zil'), index_1.ResolutionErrorCode.UnspecifiedResolver)];
                    case 1:
                        _a.sent();
                        testHelpers_1.expectSpyToBeCalled(spies);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should have a zero resolver 2', function () { return __awaiter(void 0, void 0, void 0, function () {
            var spies;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spies = testHelpers_1.mockAsyncMethods(resolution.zns, {
                            getRecordsAddresses: [
                                'zil10scu59zrf8fr6gyw5vnwcz43hg7rvah747pz5h',
                                types_1.NullAddress[1],
                            ],
                        });
                        return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(resolution.zns.resolver('paulalcock.zil'), index_1.ResolutionErrorCode.UnspecifiedResolver)];
                    case 1:
                        _a.sent();
                        testHelpers_1.expectSpyToBeCalled(spies);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should resolve with UnspecifiedCurriency', function () { return __awaiter(void 0, void 0, void 0, function () {
            var spies;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spies = testHelpers_1.mockAsyncMethods(resolution.zns, {
                            getRecordsAddresses: [
                                'zil1thd3le9wdl3ashy7h4j4dm8slm8grausdm4nyr',
                                '0x2410f1f18062b9e6f03246ba126f1f02605b1837',
                            ],
                            getResolverRecords: {
                                'whois.email.value': 'alain974@protonmail.com',
                                'whois.for_sale.value': 'true',
                            },
                        });
                        return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(resolution.addressOrThrow('macron2022.zil', 'btc'), index_1.ResolutionErrorCode.UnspecifiedCurrency)];
                    case 1:
                        _a.sent();
                        testHelpers_1.expectSpyToBeCalled(spies);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('.isSupportedDomain', function () {
        it("doesn't support zil domain when zns is disabled", function () {
            var resolution = new index_1.default({ blockchain: { zns: false } });
            expect(resolution.zns).toBeUndefined();
            expect(resolution.isSupportedDomain('hello.zil')).toBeFalsy();
        });
        it('starts with -', function () {
            expect(resolution.isSupportedDomain('-hello.zil')).toEqual(true);
        });
        it('ends with -', function () {
            expect(resolution.isSupportedDomain('hello-.zil')).toEqual(true);
        });
        it('starts and ends with -', function () {
            expect(resolution.isSupportedDomain('-hello-.zil')).toEqual(true);
        });
    });
    describe('.Hashing', function () {
        describe('.Namehash', function () {
            it('supports standard domain', function () {
                expect(resolution.zns.namehash('ny.zil')).toEqual('0xd45bcb80c1ca68da09082d7618280839a1102446b639b294d07e9a1692ec241f');
            });
            it('supports root "zil" domain', function () {
                expect(resolution.zns.namehash('zil')).toEqual('0x9915d0456b878862e822e2361da37232f626a2e47505c8795134a95d36138ed3');
            });
            it('raises ResoltuionError when domain is not supported', function () {
                testHelpers_1.expectResolutionErrorCode(function () { return resolution.zns.namehash('hello.world'); }, index_1.ResolutionErrorCode.UnsupportedDomain);
            });
        });
        describe('.Childhash', function () {
            it('checks childhash', function () {
                var zns = resolution.zns;
                var domain = 'hello.world.zil';
                var namehash = zns.namehash(domain);
                var childhash = zns.childhash(zns.namehash('world.zil'), 'hello');
                expect(namehash).toBe(childhash);
            });
            it('checks root "zil domain', function () {
                var zns = resolution.zns;
                var rootHash = '0x9915d0456b878862e822e2361da37232f626a2e47505c8795134a95d36138ed3';
                expect(zns.namehash('zil')).toBe(rootHash);
                expect(zns.childhash('0000000000000000000000000000000000000000000000000000000000000000', 'zil')).toBe(rootHash);
            });
            it('checks childhash multi level domain', function () {
                var zns = resolution.zns;
                var domain = 'ich.ni.san.yon.hello.world.zil';
                var namehash = zns.namehash(domain);
                var childhash = zns.childhash(zns.namehash('ni.san.yon.hello.world.zil'), 'ich');
                expect(childhash).toBe(namehash);
            });
        });
    });
    describe('.Record Data', function () {
        it('should return IPFS hash from zns', function () { return __awaiter(void 0, void 0, void 0, function () {
            var eye, secondEye, hash;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        eye = testHelpers_1.mockAsyncMethod(resolution.zns, 'getContractMapValue', {
                            argtypes: [],
                            arguments: [
                                '0x4e984952e867ff132cd4b70cd3f313d68c511b76',
                                '0xa9b1d3647e4deb9ce4e601c2c9e0a2fdf2d7415a',
                            ],
                            constructor: 'Record',
                        });
                        secondEye = testHelpers_1.mockAsyncMethod(resolution.zns, 'getResolverRecords', {
                            'ipfs.html.hash': 'QmefehFs5n8yQcGCVJnBMY3Hr6aMRHtsoniAhsM1KsHMSe',
                            'ipfs.html.value': 'QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHu',
                            'ipfs.redirect_domain.value': 'www.unstoppabledomains.com',
                            'whois.email.value': 'matt+test@unstoppabledomains.com',
                            'whois.for_sale.value': 'true',
                        });
                        return [4 /*yield*/, resolution.ipfsHash('ergergergerg.zil')];
                    case 1:
                        hash = _a.sent();
                        testHelpers_1.expectSpyToBeCalled([eye, secondEye]);
                        expect(hash).toStrictEqual('QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHu');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should return httpUrl associated with the domain', function () { return __awaiter(void 0, void 0, void 0, function () {
            var eye, secondEye, httpUrl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        eye = testHelpers_1.mockAsyncMethod(resolution.zns, 'getContractMapValue', {
                            argtypes: [],
                            arguments: [
                                '0x4e984952e867ff132cd4b70cd3f313d68c511b76',
                                '0xa9b1d3647e4deb9ce4e601c2c9e0a2fdf2d7415a',
                            ],
                            constructor: 'Record',
                        });
                        secondEye = testHelpers_1.mockAsyncMethod(resolution.zns, 'getResolverRecords', {
                            'ipfs.html.hash': 'QmefehFs5n8yQcGCVJnBMY3Hr6aMRHtsoniAhsM1KsHMSe',
                            'ipfs.html.value': 'QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHu',
                            'ipfs.redirect_domain.value': 'www.unstoppabledomains.com',
                            'whois.email.value': 'matt+test@unstoppabledomains.com',
                            'whois.for_sale.value': 'true',
                        });
                        return [4 /*yield*/, resolution.httpUrl('ergergergerg.zil')];
                    case 1:
                        httpUrl = _a.sent();
                        testHelpers_1.expectSpyToBeCalled([eye, secondEye]);
                        expect(httpUrl).toBe('www.unstoppabledomains.com');
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
