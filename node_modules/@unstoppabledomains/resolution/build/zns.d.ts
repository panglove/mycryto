import { Dictionary, ResolutionResponse, SourceDefinition, ZnsResolution, NamingServiceName, nodeHash } from './types';
import NamingService from './namingService';
/**
 * Class to support connection with Zilliqa naming service
 * @param network - network string such as
 * - mainnet
 * - ropsten
 * @param url - main api url such as
 * - https://mainnet.infura.io
 * @param registryAddress - address for a registry contract
 */
export default class Zns extends NamingService {
    readonly name = NamingServiceName.ZNS;
    readonly network: string;
    readonly url: string;
    readonly registryAddress?: string;
    /**
     * Source object describing the network naming service operates on
     * @param source - if specified as a string will be used as main url, if omitted then defaults are used
     * @throws ConfigurationError - when either network or url is setup incorrectly
     */
    constructor(source?: string | boolean | SourceDefinition);
    /**
     * Resolves the domain name
     * @param domain - domain name to be resolved
     * @returns A promise that resolves in a detailed crypto Resolution
     */
    resolve(domain: string): Promise<ResolutionResponse | null>;
    /**
     * Resolves domain name to a particular crypto address associated with it
     * @param domain - domain name to be resolved
     * @param currencyTicker - specific currency ticker such as
     *  - ZIL
     *  - BTC
     *  - ETH
     * @returns A promise that resolves in a string
     * @throws ResolutionError
     */
    address(domain: string, currencyTicker: string): Promise<string>;
    /**
     * Owner of the domain
     * @param domain - domain name
     * @returns An owner address of the domain
     */
    owner(domain: string): Promise<string | null>;
    /**
     * Resolves a domain
     * @param domain - domain name to be resolved
     * @returns Everything what is stored on specified domain
     */
    Resolution(domain: string): Promise<ZnsResolution>;
    ipfsHash(domain: string): Promise<string>;
    httpUrl(domain: string): Promise<string>;
    email(domain: string): Promise<string>;
    /**
     * Resolves a specific field from domain's record
     * @param domain - domain name
     * @param field - resolver record name to be queried
     * @returns Record field associated with the domain
     */
    record(domain: string, field: string): Promise<string>;
    /**
     * Resolver Records
     * @param domain - domain name to be resolved
     * @returns ZNS resolver records in an plain key-value format
     */
    records(domain: string): Promise<Dictionary<string>>;
    /**
     * Checks if domain is supported by zns
     */
    isSupportedDomain(domain: string): boolean;
    /**
     * Checks if zns is supported by current Resolution instance
     */
    isSupportedNetwork(): boolean;
    /**
     * Produces ZNS namehash of a domain
     * @param domain - domain name to be hashed
     * @returns ZNS namehash
     */
    namehash(domain: string): string;
    /**
     * Returns the childhash
     * @param parent - nodehash of a parent
     * @param label - child
     */
    childhash(parent: nodeHash, label: string): string;
    /**
     * get the resolver address from domain
     * @param domain - domain name
     * @throws ResolutionError with codes
     *  - UnregisteredDomain if there is no owner for such a domain
     *  - UnspecifiedResolver if there is no resolver for such a domain
     */
    resolver(domain: string): Promise<string>;
    private getRecordOrThrow;
    private getRecordFieldOrThrow;
    private getRecordsAddresses;
    private getResolverRecords;
    private structureResolverRecords;
    private resolverAddress;
    private fetchSubState;
    private getContractField;
    private getContractMapValue;
}
