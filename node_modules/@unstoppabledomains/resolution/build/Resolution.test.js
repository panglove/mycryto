"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var nock_1 = __importDefault(require("nock"));
var index_1 = __importStar(require("./index"));
var types_1 = require("./types");
var testHelpers_1 = require("./utils/testHelpers");
var node_fetch_1 = __importDefault(require("node-fetch"));
try {
    var dotenv = require('dotenv');
    dotenv.config();
}
catch (err) {
    console.warn('dotenv is not installed');
}
beforeEach(function () {
    nock_1.default.cleanAll();
    jest.restoreAllMocks();
});
describe('Resolution', function () {
    it('should get a valid resolution instance', function () { return __awaiter(void 0, void 0, void 0, function () {
        var infura, resolution;
        return __generator(this, function (_a) {
            infura = process.env.UNSTOPPABLE_RESOLUTION_INFURA_PROJECTID;
            if (!infura) {
                console.warn('infura id is not set');
            }
            resolution = index_1.default.infura(infura);
            expect(resolution.ens).toBeDefined();
            expect(resolution.ens.url).toBe("https://mainnet.infura.com/v3/" + infura);
            expect(resolution.cns).toBeDefined();
            expect(resolution.cns.url).toBe("https://mainnet.infura.com/v3/" + infura);
            return [2 /*return*/];
        });
    }); });
    it('should get a configured with provider resolution instance', function () { return __awaiter(void 0, void 0, void 0, function () {
        var provider, resolution, ethAddress;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    provider = {
                        sendAsync: function (method, params) {
                            return node_fetch_1.default(testHelpers_1.secretInfuraLink(), {
                                method: 'POST',
                                body: JSON.stringify({
                                    method: method,
                                    params: params,
                                    jsonrpc: '2.0',
                                    id: 1,
                                }),
                            });
                        },
                    };
                    resolution = index_1.default.provider(provider);
                    return [4 /*yield*/, resolution.addressOrThrow('brad.crypto', 'ETH')];
                case 1:
                    ethAddress = _a.sent();
                    expect(ethAddress).toBe('0x45b31e01AA6f42F0549aD482BE81635ED3149abb');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks Resolution#addressOrThrow error #1', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(resolution.addressOrThrow('sdncdoncvdinvcsdncs.zil', 'ZIL'), index_1.ResolutionErrorCode.UnregisteredDomain)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks Resolution#addressOrThrow error #2', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(resolution.addressOrThrow('brad.zil', 'INVALID_CURRENCY_SYMBOL'), index_1.ResolutionErrorCode.UnspecifiedCurrency)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it('resolves non-existing domain zone with throw', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default({ blockchain: true });
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(resolution.addressOrThrow('bogdangusiev.qq', 'ZIL'), index_1.ResolutionErrorCode.UnsupportedDomain)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it('resolves non-existing domain zone via safe address', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default({ blockchain: true });
                    return [4 /*yield*/, resolution.address('bogdangusiev.qq', 'ZIL')];
                case 1:
                    result = _a.sent();
                    expect(result).toEqual(null);
                    return [2 /*return*/];
            }
        });
    }); });
    it('provides empty response constant', function () { return __awaiter(void 0, void 0, void 0, function () {
        var response;
        return __generator(this, function (_a) {
            response = types_1.UnclaimedDomainResponse;
            expect(response.addresses).toEqual({});
            expect(response.meta.owner).toEqual(null);
            return [2 /*return*/];
        });
    }); });
    it('checks the isSupportedDomainInNetwork', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution, result;
        return __generator(this, function (_a) {
            resolution = new index_1.default();
            result = resolution.isSupportedDomainInNetwork('brad.zil');
            expect(result).toBe(true);
            return [2 /*return*/];
        });
    }); });
    it('checks namehash for unsupported domain', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(function () { return resolution.namehash('something.hello.com'); }, index_1.ResolutionErrorCode.UnsupportedDomain)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks return of IPFS hash for brad.zil', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution, spies, hash;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default();
                    spies = testHelpers_1.mockAsyncMethods(resolution.zns, {
                        records: {
                            'crypto.BCH.address': 'qrq4sk49ayvepqz7j7ep8x4km2qp8lauvcnzhveyu6',
                            'crypto.BTC.address': '1EVt92qQnaLDcmVFtHivRJaunG2mf2C3mB',
                            'crypto.DASH.address': 'XnixreEBqFuSLnDSLNbfqMH1GsZk7cgW4j',
                            'crypto.ETH.address': '0x45b31e01AA6f42F0549aD482BE81635ED3149abb',
                            'crypto.LTC.address': 'LetmswTW3b7dgJ46mXuiXMUY17XbK29UmL',
                            'crypto.XMR.address': '447d7TVFkoQ57k3jm3wGKoEAkfEym59mK96Xw5yWamDNFGaLKW5wL2qK5RMTDKGSvYfQYVN7dLSrLdkwtKH3hwbSCQCu26d',
                            'crypto.ZEC.address': 't1h7ttmQvWCSH1wfrcmvT4mZJfGw2DgCSqV',
                            'crypto.ZIL.address': 'zil1yu5u4hegy9v3xgluweg4en54zm8f8auwxu0xxj',
                            'ipfs.html.value': 'QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHuK',
                            'ipfs.redirect_domain.value': 'www.unstoppabledomains.com',
                        },
                    });
                    return [4 /*yield*/, resolution.ipfsHash('brad.zil')];
                case 1:
                    hash = _a.sent();
                    testHelpers_1.expectSpyToBeCalled(spies);
                    expect(hash).toBe('QmVaAtQbi3EtsfpKoLzALm6vXphdi2KjMgxEDKeGg6wHuK');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks return of email for ergergergerg.zil', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution, email;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default();
                    return [4 /*yield*/, resolution.email('ergergergerg.zil')];
                case 1:
                    email = _a.sent();
                    expect(email).toBe('matt+test@unstoppabledomains.com');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks error for  email on brad.zil', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(resolution.email('brad.zil'), index_1.ResolutionErrorCode.RecordNotFound)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be invalid domain', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(function () { return resolution.namehash('-hello.eth'); }, index_1.ResolutionErrorCode.UnsupportedDomain)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be invalid domain 2', function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(function () { return resolution.namehash('whatever-.eth'); }, index_1.ResolutionErrorCode.UnsupportedDomain)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be invalid domain 3', function () { return __awaiter(void 0, void 0, void 0, function () {
        var cnsInvalidDomain, ensInvalidDomain, znsInvalidDomain, resolution;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    cnsInvalidDomain = 'hello..crypto';
                    ensInvalidDomain = 'hello..eth';
                    znsInvalidDomain = 'hello..zil';
                    resolution = new index_1.default();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(function () { return resolution.namehash(cnsInvalidDomain); }, index_1.ResolutionErrorCode.UnsupportedDomain)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(function () { return resolution.namehash(ensInvalidDomain); }, index_1.ResolutionErrorCode.UnsupportedDomain)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, testHelpers_1.expectResolutionErrorCode(function () { return resolution.namehash(znsInvalidDomain); }, index_1.ResolutionErrorCode.UnsupportedDomain)];
                case 3:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it("domains \"brad.crypto\" and \"Brad.crypto\" should return the same results", function () { return __awaiter(void 0, void 0, void 0, function () {
        var resolution, eyes, capital, lower;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolution = new index_1.default({ blockchain: { cns: { url: testHelpers_1.secretInfuraLink() } } });
                    eyes = testHelpers_1.mockAsyncMethods(resolution.cns, { getResolver: '0xBD5F5ec7ed5f19b53726344540296C02584A5237',
                        getRecord: "0x45b31e01AA6f42F0549aD482BE81635ED3149abb", });
                    return [4 /*yield*/, resolution.addressOrThrow('Brad.crypto', 'eth')];
                case 1:
                    capital = _a.sent();
                    testHelpers_1.expectSpyToBeCalled(eyes);
                    return [4 /*yield*/, resolution.addressOrThrow('brad.crypto', 'eth')];
                case 2:
                    lower = _a.sent();
                    testHelpers_1.expectSpyToBeCalled(eyes);
                    expect(capital).toStrictEqual(lower);
                    return [2 /*return*/];
            }
        });
    }); });
    describe('serviceName', function () {
        it('checks ens service name', function () {
            var resolution = new index_1.default();
            var serviceName = resolution.serviceName('domain.eth');
            expect(serviceName).toBe('ENS');
        });
        it('checks ens service name 2', function () {
            var resolution = new index_1.default();
            var serviceName = resolution.serviceName('domain.luxe');
            expect(serviceName).toBe('ENS');
        });
        it('checks ens service name', function () {
            var resolution = new index_1.default();
            var serviceName = resolution.serviceName('domain.xyz');
            expect(serviceName).toBe('ENS');
        });
        it('checks zns service name', function () {
            var resolution = new index_1.default();
            var serviceName = resolution.serviceName('domain.zil');
            expect(serviceName).toBe('ZNS');
        });
        it('checks cns service name', function () {
            var resolution = new index_1.default();
            var serviceName = resolution.serviceName('domain.crypto');
            expect(serviceName).toBe('CNS');
        });
        it('checks naming service via api', function () {
            var resolution = new index_1.default({ blockchain: false });
            var serviceName = resolution.serviceName('domain.zil');
            expect(serviceName).toBe('ZNS');
        });
        it('checks naming service via api 2', function () {
            var resolution = new index_1.default({ blockchain: false });
            var serviceName = resolution.serviceName('domain.luxe');
            expect(serviceName).toBe('ENS');
        });
        it('checks naming service via api 3', function () {
            var resolution = new index_1.default({ blockchain: false });
            var serviceName = resolution.serviceName('domain.xyz');
            expect(serviceName).toBe('ENS');
        });
        it('checks naming service via api 4', function () {
            var resolution = new index_1.default({ blockchain: false });
            var serviceName = resolution.serviceName('domain.eth');
            expect(serviceName).toBe('ENS');
        });
        it('checks naming service via api 5', function () {
            var resolution = new index_1.default({ blockchain: false });
            var serviceName = resolution.serviceName('domain.crypto');
            expect(serviceName).toBe('CNS');
        });
    });
    describe('isValidHash', function () {
        it('works', function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolution, domain, hash, invalidHash;
            return __generator(this, function (_a) {
                resolution = new index_1.default();
                domain = 'hello.world.zil';
                hash = resolution.namehash(domain);
                invalidHash = resolution.namehash('world.zil');
                expect(resolution.isValidHash(domain, hash)).toEqual(true);
                expect(resolution.isValidHash(domain, invalidHash)).toEqual(false);
                return [2 /*return*/];
            });
        }); });
    });
    describe('.Hashing', function () {
        describe('.childhash', function () {
            it('checks childhash', function () {
                var resolution = new index_1.default();
                var domain = 'hello.world.zil';
                var namehash = resolution.namehash(domain);
                var childhash = resolution.childhash(resolution.namehash('world.zil'), 'hello', types_1.NamingServiceName.ZNS);
                expect(childhash).toBe(namehash);
            });
            it('checks childhash multi level domain', function () {
                var cns = new index_1.default().cns;
                var domain = 'ich.ni.san.yon.hello.world.crypto';
                var namehash = cns.namehash(domain);
                var childhash = cns.childhash(cns.namehash('ni.san.yon.hello.world.crypto'), 'ich');
                expect(childhash).toBe(namehash);
            });
        });
    });
    describe('Providers', function () {
        it('should work with custom provider', function () { return __awaiter(void 0, void 0, void 0, function () {
            var provider, resolution, ethAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        provider = {
                            sendAsync: function (method, params) {
                                return node_fetch_1.default(testHelpers_1.secretInfuraLink(), {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        method: method,
                                        params: params,
                                        jsonrpc: '2.0',
                                        id: 1,
                                    }),
                                });
                            },
                        };
                        resolution = new index_1.default({
                            blockchain: { web3Provider: provider },
                        });
                        return [4 /*yield*/, resolution.addressOrThrow('brad.crypto', 'ETH')];
                    case 1:
                        ethAddress = _a.sent();
                        expect(ethAddress).toBe('0x45b31e01AA6f42F0549aD482BE81635ED3149abb');
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
