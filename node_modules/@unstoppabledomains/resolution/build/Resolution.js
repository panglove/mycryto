"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ens_1 = __importDefault(require("./ens"));
var zns_1 = __importDefault(require("./zns"));
var cns_1 = __importDefault(require("./cns"));
var unstoppableAPI_1 = __importDefault(require("./unstoppableAPI"));
var types_1 = require("./types");
var resolutionError_1 = __importStar(require("./resolutionError"));
var utils_1 = require("./utils");
/**
 * Blockchain domain Resolution library - Resolution.
 * @example
 * ```
 * let Resolution = new Resolution({blockchain: {ens: {url: 'https://mainnet.infura.io', network: 'mainnet'}}});
 * let domain = brad.zil
 * let Resolution = Resolution.address(domain);
 * ```
 */
var Resolution = /** @class */ (function () {
    /**
     * Resolution constructor
     * @property blockchain - main configuration object
     */
    function Resolution(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.blockchain, blockchain = _c === void 0 ? true : _c, _d = _b.api, api = _d === void 0 ? types_1.DefaultAPI : _d;
        this.blockchain = !!blockchain;
        if (blockchain) {
            if (blockchain == true) {
                blockchain = {};
            }
            if (blockchain.ens === undefined) {
                blockchain.ens = true;
            }
            if (blockchain.zns === undefined) {
                blockchain.zns = true;
            }
            if (blockchain.cns === undefined) {
                blockchain.cns = true;
            }
            if (blockchain.ens) {
                this.ens = new ens_1.default(blockchain.ens, blockchain.web3Provider);
            }
            if (blockchain.zns) {
                this.zns = new zns_1.default(blockchain.zns);
            }
            if (blockchain.cns) {
                this.cns = new cns_1.default(blockchain.cns, blockchain.web3Provider);
            }
        }
        else {
            this.api = new unstoppableAPI_1.default(api.url);
        }
    }
    /**
     * Creates a resolution with configured infura id for ens and cns
     * @param infura infura project id
     */
    Resolution.infura = function (infura) {
        return new this({
            blockchain: {
                ens: { url: utils_1.signedInfuraLink(infura), network: 'mainnet' },
                cns: { url: utils_1.signedInfuraLink(infura), network: 'mainnet' },
            },
        });
    };
    /**
     * Creates a resolution instance with configured provider
     * @param provider - any provider with sendAsync function impelmented
     */
    Resolution.provider = function (provider) {
        return new this({ blockchain: { web3Provider: provider } });
    };
    /**
     * Creates a resolution instance from configured jsonRPCProvider
     * @param provider - any jsonRPCprovider will work as long as it's prototype has send(method, params): Promise<any> method
     */
    Resolution.jsonRPCprovider = function (provider) {
        return new this({ blockchain: { web3Provider: provider.send } });
    };
    /**
     * Resolves the given domain
     * @async
     * @param domain - domain name to be resolved
     * @returns A promise that resolves in an object
     */
    Resolution.prototype.resolve = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        return [4 /*yield*/, method.resolve(domain)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result || types_1.UnclaimedDomainResponse];
                }
            });
        });
    };
    /**
     * Resolves give domain name to a specific currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param currencyTicker - currency ticker like BTC, ETH, ZIL
     * @returns A promise that resolves in an address or null
     */
    Resolution.prototype.address = function (domain, currencyTicker) {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.addressOrThrow(domain, currencyTicker)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        error_1 = _a.sent();
                        if (error_1 instanceof resolutionError_1.default) {
                            return [2 /*return*/, null];
                        }
                        else {
                            throw error_1;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resolves the IPFS hash configured for domain records on ZNS
     * @param domain - domain name
     * @throws ResolutionError
     */
    Resolution.prototype.ipfsHash = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        return [4 /*yield*/, this.getNamingMethodOrThrow(domain).ipfsHash(domain)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolves the httpUrl attached to domain
     * @param domain - domain name
     */
    Resolution.prototype.httpUrl = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        return [4 /*yield*/, this.getNamingMethodOrThrow(domain).httpUrl(domain)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolves the ipfs redirect url for a supported domain records
     * @deprecated - use Resolution#httpUrl instead
     * @param domain - domain name
     * @throws ResolutionError
     * @returns A Promise that resolves in redirect url
     */
    Resolution.prototype.ipfsRedirect = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.warn('Resolution#ipfsRedirect is depricated since 1.0.15, use Resolution#httpUrl instead');
                        return [4 /*yield*/, this.getNamingMethodOrThrow(domain).record(domain, 'ipfs.redirect_domain.value')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolves the ipfs email field from whois configurations
     * @param domain - domain name
     * @throws ResolutionError
     * @returns A Promise that resolves in an email address configured for this domain whois
     */
    Resolution.prototype.email = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        return [4 /*yield*/, this.getNamingMethodOrThrow(domain).email(domain)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolves given domain to a specific currency address or throws an error
     * @param domain - domain name
     * @param currencyTicker - currency ticker such as
     *  - ZIL
     *  - BTC
     *  - ETH
     * @throws ResolutionError if address is not found
     */
    Resolution.prototype.addressOrThrow = function (domain, currencyTicker) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        return [4 /*yield*/, method.address(domain, currencyTicker)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Resolution.prototype.resolver = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        return [4 /*yield*/, this.getNamingMethodOrThrow(domain).resolver(domain)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Owner of the domain
     * @param domain - domain name
     * @returns An owner address of the domain
     */
    Resolution.prototype.owner = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        method = this.getNamingMethod(domain);
                        return [4 /*yield*/, method.owner(domain)];
                    case 1: return [2 /*return*/, (_a.sent()) || null];
                }
            });
        });
    };
    /**
     * This method is only for ens at the moment. Reverse the ens address to a ens registered domain name
     * @async
     * @param address - address you wish to reverse
     * @param currencyTicker - currency ticker like BTC, ETH, ZIL
     * @returns Domain name attached to this address
     */
    Resolution.prototype.reverse = function (address, currencyTicker) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.checkIfSet(types_1.NamingServiceName.ENS))
                            return [2 /*return*/, null];
                        return [4 /*yield*/, this.ens.reverse(address, currencyTicker)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Produce a namehash from supported naming service
     * @param domain - domain name to be hashed
     * @returns Namehash either for ENS or ZNS
     * @throws ResolutionError with UnsupportedDomain error code if domain extension is unknown
     */
    Resolution.prototype.namehash = function (domain) {
        domain = this.prepareDomain(domain);
        return this.getNamingMethodOrThrow(domain).namehash(domain);
    };
    /**
     * returns a childhash for specific namingService
     * @param parent -> hash for parent
     * @param label -> hash for label
     * @param method -> "ENS", "CNS" or "ZNS"
     */
    Resolution.prototype.childhash = function (parent, label, method) {
        switch (method) {
            case types_1.NamingServiceName.ENS:
                if (!this.checkIfSet(types_1.NamingServiceName.ENS))
                    return null;
                return this.ens.childhash(parent, label);
            case types_1.NamingServiceName.CNS:
                if (!this.checkIfSet(types_1.NamingServiceName.CNS))
                    return null;
                return this.cns.childhash(parent, label);
            case types_1.NamingServiceName.ZNS:
                if (!this.checkIfSet(types_1.NamingServiceName.ZNS))
                    return null;
                return this.zns.childhash(parent, label);
            default:
                throw new Error('Incorrect method is provided');
        }
    };
    /**
     * Checks weather the domain name matches the hash
     * @param domain - domain name to check againt
     * @param hash - hash obtained from the blockchain
     */
    Resolution.prototype.isValidHash = function (domain, hash) {
        domain = this.prepareDomain(domain);
        return this.namehash(domain) === hash;
    };
    /**
     * Checks if the domain is in valid format
     * @param domain - domain name to be checked
     */
    Resolution.prototype.isSupportedDomain = function (domain) {
        domain = this.prepareDomain(domain);
        return !!this.getNamingMethod(domain);
    };
    /**
     * Checks if the domain is supported by the specified network as well as if it is in valid format
     * @param domain - domain name to be checked
     */
    Resolution.prototype.isSupportedDomainInNetwork = function (domain) {
        domain = this.prepareDomain(domain);
        var method = this.getNamingMethod(domain);
        return method && method.isSupportedNetwork();
    };
    Resolution.prototype.serviceName = function (domain) {
        domain = this.prepareDomain(domain);
        return this.getNamingMethodOrThrow(domain).serviceName(domain);
    };
    /**
     * Used internally to get the right method (ens or zns)
     * @param domain - domain name
     */
    Resolution.prototype.getNamingMethod = function (domain) {
        domain = this.prepareDomain(domain);
        var methods = this.blockchain
            ? [this.ens, this.zns, this.cns]
            : [this.api];
        var method = methods.find(function (method) { return method && method.isSupportedDomain(domain); });
        return method;
    };
    Resolution.prototype.getNamingMethodOrThrow = function (domain) {
        domain = this.prepareDomain(domain);
        var method = this.getNamingMethod(domain);
        if (!method)
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                domain: domain,
            });
        return method;
    };
    Resolution.prototype.checkIfSet = function (blockchain) {
        if (!this[blockchain.toLowerCase()])
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.NamingServiceDown, {
                method: types_1.NamingServiceName[blockchain],
            });
        return true;
    };
    Resolution.prototype.prepareDomain = function (domain) {
        return domain ? domain.trim().toLowerCase() : "";
    };
    return Resolution;
}());
exports.Resolution = Resolution;
exports.default = Resolution;
