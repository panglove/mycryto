{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal[\"default\"].signature : function (a) {\n  return a;\n};\n\nimport BN from 'bn.js';\nimport { DeviceList } from 'trezor.js';\nimport mapValues from 'lodash/mapValues';\nimport { addHexPrefix } from 'ethereumjs-util';\nimport EthTx from 'ethereumjs-tx';\nimport { padLeftEven } from 'libs/values';\nimport { stripHexPrefixAndLower } from 'libs/formatters';\nimport { showPinPrompt } from '../views/pin';\nimport { showPassphrasePrompt } from '../views/passphrase';\nimport config from './msg-config';\nvar deviceList = new DeviceList({\n  config: config\n}); // Keep session in memory so that we're not constantly re-acquiring\n// Null it out if session is grabbed somewhere else first\n\nvar currentSession;\n\nfunction getSession() {\n  return _getSession.apply(this, arguments);\n}\n\nfunction _getSession() {\n  _getSession = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee5() {\n    var _ref2, device, session;\n\n    return regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!currentSession) {\n              _context5.next = 2;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", currentSession);\n\n          case 2:\n            _context5.next = 4;\n            return deviceList.acquireFirstDevice(true);\n\n          case 4:\n            _ref2 = _context5.sent;\n            device = _ref2.device;\n            session = _ref2.session;\n            device.on('disconnect', function () {\n              return currentSession = null;\n            });\n            device.on('changedSessions', function (_, isUsedHere) {\n              if (isUsedHere) {\n                currentSession = null;\n              }\n            });\n            device.on('pin', function (_, cb) {\n              showPinPrompt().then(function (pin) {\n                cb(undefined, pin);\n              })[\"catch\"](function (err) {\n                console.error('PIN entry failed', err);\n                cb(err);\n              });\n            });\n            device.on('passphrase', function (cb) {\n              showPassphrasePrompt().then(function (passphrase) {\n                cb(undefined, passphrase);\n              })[\"catch\"](function (err) {\n                console.error('Passphrase entry failed', err);\n                cb(err);\n              });\n            });\n            currentSession = session;\n            return _context5.abrupt(\"return\", currentSession);\n\n          case 13:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _getSession.apply(this, arguments);\n}\n\nvar Trezor = {\n  getChainCode: function () {\n    var _getChainCode = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(dpath) {\n      var session, _ref, message;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return getSession();\n\n            case 2:\n              session = _context.sent;\n              _context.next = 5;\n              return session.getPublicKey(parseHDPath(dpath));\n\n            case 5:\n              _ref = _context.sent;\n              message = _ref.message;\n              return _context.abrupt(\"return\", {\n                chainCode: message.node.chain_code,\n                publicKey: message.node.public_key\n              });\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function getChainCode(_x) {\n      return _getChainCode.apply(this, arguments);\n    }\n\n    return getChainCode;\n  }(),\n  signTransaction: function () {\n    var _signTransaction = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee2(tx, dpath) {\n      var chainId, strTx, cleanedTx, session, res, signedTx;\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              chainId = tx.chainId, strTx = _objectWithoutProperties(tx, [\"chainId\"]);\n              cleanedTx = mapValues(mapValues(strTx, stripHexPrefixAndLower), padLeftEven);\n              _context2.next = 4;\n              return getSession();\n\n            case 4:\n              session = _context2.sent;\n              _context2.next = 7;\n              return session.signEthTx(parseHDPath(dpath), cleanedTx.nonce, cleanedTx.gasPrice, cleanedTx.gasLimit, cleanedTx.to, cleanedTx.value, cleanedTx.data, chainId);\n\n            case 7:\n              res = _context2.sent;\n              signedTx = new EthTx(_objectSpread({}, strTx, {\n                v: addHexPrefix(new BN(res.v).toString(16)),\n                r: addHexPrefix(res.r.toString()),\n                s: addHexPrefix(res.s)\n              }));\n              return _context2.abrupt(\"return\", {\n                signedTransaction: signedTx.serialize().toString('hex')\n              });\n\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function signTransaction(_x2, _x3) {\n      return _signTransaction.apply(this, arguments);\n    }\n\n    return signTransaction;\n  }(),\n  signMessage: function () {\n    var _signMessage = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee3() {\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              throw new Error('Signing is not supported on TREZOR devices');\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    function signMessage() {\n      return _signMessage.apply(this, arguments);\n    }\n\n    return signMessage;\n  }(),\n  displayAddress: function () {\n    var _displayAddress = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee4(path) {\n      var session;\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return getSession();\n\n            case 2:\n              session = _context4.sent;\n              _context4.prev = 3;\n              _context4.next = 6;\n              return session.ethereumGetAddress(parseHDPath(path), true);\n\n            case 6:\n              return _context4.abrupt(\"return\", {\n                success: true\n              });\n\n            case 9:\n              _context4.prev = 9;\n              _context4.t0 = _context4[\"catch\"](3);\n              return _context4.abrupt(\"return\", {\n                success: false\n              });\n\n            case 12:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, null, [[3, 9]]);\n    }));\n\n    function displayAddress(_x4) {\n      return _displayAddress.apply(this, arguments);\n    }\n\n    return displayAddress;\n  }()\n}; // Lifted from https://github.com/trezor/connect/blob/7919d47ca9d483cf303d77907505ccc7d389c68c/popup/src/utils/path.js#L110\n// tslint:disable no-bitwise\n\nfunction parseHDPath(path) {\n  return path.toLowerCase().split('/').filter(function (p) {\n    return p !== 'm';\n  }).map(function (p) {\n    var hardened = false;\n    var n = parseInt(p, 10);\n\n    if (p[p.length - 1] === \"'\") {\n      hardened = true;\n      p = p.substr(0, p.length - 1);\n    }\n\n    if (isNaN(n)) {\n      throw new Error('Invalid path specified');\n    }\n\n    if (hardened) {\n      // hardened index\n      n = (n | 0x80000000) >>> 0;\n    }\n\n    return n;\n  });\n}\n\nvar _default = Trezor;\nexport default _default;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(deviceList, \"deviceList\", \"/root/MyCrypto/shared/enclave/server/wallets/trezor.ts\");\n  reactHotLoader.register(currentSession, \"currentSession\", \"/root/MyCrypto/shared/enclave/server/wallets/trezor.ts\");\n  reactHotLoader.register(getSession, \"getSession\", \"/root/MyCrypto/shared/enclave/server/wallets/trezor.ts\");\n  reactHotLoader.register(Trezor, \"Trezor\", \"/root/MyCrypto/shared/enclave/server/wallets/trezor.ts\");\n  reactHotLoader.register(parseHDPath, \"parseHDPath\", \"/root/MyCrypto/shared/enclave/server/wallets/trezor.ts\");\n  reactHotLoader.register(_default, \"default\", \"/root/MyCrypto/shared/enclave/server/wallets/trezor.ts\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"module"}