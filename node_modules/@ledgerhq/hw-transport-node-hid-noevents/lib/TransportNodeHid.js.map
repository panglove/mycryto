{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["filterInterface","includes","process","platform","device","usagePage","interface","getDevices","devices","filter","isDisconnectedError","e","message","indexOf","TransportNodeHidNoEvents","path","Promise","resolve","HID","info","getDeviceInfo","deviceModel","serialNumber","parseInt","exchangeBusyPromise","close","isSupported","list","map","d","listen","observer","forEach","productId","next","type","descriptor","complete","unsubscribe","channel","Math","floor","random","packetSize","disconnected","setDisconnected","emit","writeHID","content","data","i","length","push","write","reject","readHID","read","res","buffer","Buffer","from","exchange","apdu","exchangeAtomicImpl","debug","toString","framing","blocks","makeBlocks","result","acc","getReducedResult","reduceResponse"],"mappings":";;;;;;;;AAEA;;;;AACA;;;;AAMA;;AACA;;;;AAGA;;;;;;;;;;;;AAEA,IAAMA,kBAAkB,SAAlBA,eAAkB;AAAA,SACtB,CAAC,OAAD,EAAU,QAAV,EAAoBC,QAApB,CAA6BC,QAAQC,QAArC,IACI;AACAC,SAAOC,SAAP,KAAqB,MAFzB,GAGID,OAAOE,SAAP,KAAqB,CAJH;AAAA,CAAxB;;AAMA,SAASC,UAAT,GAAgC;AAC9B;AACA,SAAO,kBAAIC,OAAJ,6BAA+B,GAA/B,EAAoCC,MAApC,CAA2CT,eAA3C,CAAP;AACD;;AAED,IAAMU,sBAAsB,SAAtBA,mBAAsB;AAAA,SAC1BC,KAAKA,EAAEC,OAAP,IAAkBD,EAAEC,OAAF,CAAUC,OAAV,CAAkB,KAAlB,KAA4B,CADpB;AAAA,CAA5B;;AAGA;;;;;;;;IAOqBC,wB;;;;;;;AA+BnB;;;;;AAxBA;;;;0FA2BkBC,I;;;;;;qBACZA,I;;;;;iDACKC,QAAQC,OAAR,CAAgB,IAAIH,wBAAJ,CAA6B,IAAI,kBAAII,GAAR,CAAYH,IAAZ,CAA7B,CAAhB,C;;;AAEHX,sB,GAASG,aAAa,CAAb,C;;oBACVH,M;;;;;sBAAc,2BAAmB,UAAnB,EAA+B,UAA/B,C;;;iDACZY,QAAQC,OAAR,CACL,IAAIH,wBAAJ,CAA6B,IAAI,kBAAII,GAAR,CAAYd,OAAOW,IAAnB,CAA7B,CADK,C;;;;;;;;;;;;;;;;;AA3BT;;;AAZA;;;;;;AAmDA,oCAAYX,MAAZ,EAA6B;AAAA;;AAAA;;AAAA;;AAE3B,UAAKA,MAAL,GAAcA,MAAd;AACA,QAAMe,OAAOf,OAAOgB,aAAP,EAAb;AACA,UAAKC,WAAL,GACEF,QAAQA,KAAKG,YAAb,GACI,mCAAqBC,SAASJ,KAAKG,YAAd,EAA4B,EAA5B,CAArB,CADJ,GAEI,IAHN;AAJ2B;AAQ5B;;AA6CD;;;;;;;;;qCAkCiB,CAAE;;AAEnB;;;;;;;;;;;;;uBAIQ,KAAKE,mB;;;AACX,qBAAKpB,MAAL,CAAYqB,KAAZ;;;;;;;;;;;;;;;;;;;;;AAlJiBX,wB,CAIZY,W,GAAc;AAAA,SACnBV,QAAQC,OAAR,CAAgB,OAAO,kBAAIC,GAAX,KAAmB,UAAnC,CADmB;AAAA,C;;AAJFJ,wB,CAUZa,I,GAAO;AAAA,SACZX,QAAQC,OAAR,CAAgBV,aAAaqB,GAAb,CAAiB;AAAA,WAAKC,EAAEd,IAAP;AAAA,GAAjB,CAAhB,CADY;AAAA,C;;AAVKD,wB,CAeZgB,M,GAAS,UACdC,QADc,EAEG;AACjBxB,eAAayB,OAAb,CAAqB,kBAAU;AAC7B,QAAMX,cAAc,mCAAqBjB,OAAO6B,SAA5B,CAApB;AACAF,aAASG,IAAT,CAAc;AACZC,YAAM,KADM;AAEZC,kBAAYhC,OAAOW,IAFP;AAGZM,8BAHY;AAIZjB;AAJY,KAAd;AAMD,GARD;AASA2B,WAASM,QAAT;AACA,SAAO,EAAEC,aAAa,uBAAM,CAAE,CAAvB,EAAP;AACD,C;;;;;OAmBDC,O,GAAUC,KAAKC,KAAL,CAAWD,KAAKE,MAAL,KAAgB,MAA3B,C;OACVC,U,GAAa,E;OACbC,Y,GAAe,K;;OAYfC,e,GAAkB,YAAM;AACtB,QAAI,CAAC,OAAKD,YAAV,EAAwB;AACtB,aAAKE,IAAL,CAAU,YAAV;AACA,aAAKF,YAAL,GAAoB,IAApB;AACD;AACF,G;;OAEDG,Q,GAAW,UAACC,OAAD,EAAoC;AAC7C,QAAMC,OAAO,CAAC,IAAD,CAAb;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,QAAQG,MAA5B,EAAoCD,GAApC,EAAyC;AACvCD,WAAKG,IAAL,CAAUJ,QAAQE,CAAR,CAAV;AACD;AACD,QAAI;AACF,aAAK9C,MAAL,CAAYiD,KAAZ,CAAkBJ,IAAlB;AACA,aAAOjC,QAAQC,OAAR,EAAP;AACD,KAHD,CAGE,OAAON,CAAP,EAAU;AACV,UAAID,oBAAoBC,CAApB,CAAJ,EAA4B;AAC1B,eAAKkC,eAAL;AACA,eAAO7B,QAAQsC,MAAR,CAAe,+BAAuB3C,EAAEC,OAAzB,CAAf,CAAP;AACD;AACD,aAAOI,QAAQsC,MAAR,CAAe3C,CAAf,CAAP;AACD;AACF,G;;OAED4C,O,GAAU;AAAA,WACR,IAAIvC,OAAJ,CAAY,UAACC,OAAD,EAAUqC,MAAV;AAAA,aACV,OAAKlD,MAAL,CAAYoD,IAAZ,CAAiB,UAAC7C,CAAD,EAAI8C,GAAJ,EAAY;AAC3B,YAAI,CAACA,GAAL,EAAU;AACR,iBAAOH,OAAO,gCAAP,CAAP;AACD;AACD,YAAI3C,CAAJ,EAAO;AACL,cAAID,oBAAoBC,CAApB,CAAJ,EAA4B;AAC1B,mBAAKkC,eAAL;AACA,mBAAOS,OAAO,+BAAuB3C,EAAEC,OAAzB,CAAP,CAAP;AACD;AACD0C,iBAAO3C,CAAP;AACD,SAND,MAMO;AACL,cAAM+C,SAASC,OAAOC,IAAP,CAAYH,GAAZ,CAAf;AACAxC,kBAAQyC,MAAR;AACD;AACF,OAdD,CADU;AAAA,KAAZ,CADQ;AAAA,G;;OAwBVG,Q,GAAW,UAACC,IAAD;AAAA,WACT,OAAKC,kBAAL,yDAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AACdC,mBADc,UACdA,KADc,EACPzB,OADO,UACPA,OADO,EACEI,UADF,UACEA,UADF;;AAEtB,kBAAIqB,KAAJ,EAAW;AACTA,sBAAM,OAAOF,KAAKG,QAAL,CAAc,KAAd,CAAb;AACD;;AAEKC,qBANgB,GAMN,0BAAW3B,OAAX,EAAoBI,UAApB,CANM;;AAQtB;;AACMwB,oBATgB,GASPD,QAAQE,UAAR,CAAmBN,IAAnB,CATO;AAUbZ,eAVa,GAUT,CAVS;;AAAA;AAAA,oBAUNA,IAAIiB,OAAOhB,MAVL;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAWd,OAAKJ,QAAL,CAAcoB,OAAOjB,CAAP,CAAd,CAXc;;AAAA;AAUaA,iBAVb;AAAA;AAAA;;AAAA;;AActB;AACImB,oBAfkB;AAgBlBC,iBAhBkB;;AAAA;AAAA,kBAiBbD,SAASH,QAAQK,gBAAR,CAAyBD,GAAzB,CAjBI;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAkBC,OAAKf,OAAL,EAlBD;;AAAA;AAkBdG,oBAlBc;;AAmBpBY,oBAAMJ,QAAQM,cAAR,CAAuBF,GAAvB,EAA4BZ,MAA5B,CAAN;AAnBoB;AAAA;;AAAA;;AAsBtB,kBAAIM,KAAJ,EAAW;AACTA,sBAAM,OAAOK,OAAOJ,QAAP,CAAgB,KAAhB,CAAb;AACD;AAxBqB,gDAyBfI,MAzBe;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAxB,GADS;AAAA,G;;;kBA9GQvD,wB","file":"TransportNodeHid.js","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport { ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { TransportError, DisconnectedDevice } from \"@ledgerhq/errors\";\n\nconst filterInterface = device =>\n  [\"win32\", \"darwin\"].includes(process.platform)\n    ? // $FlowFixMe\n      device.usagePage === 0xffa0\n    : device.interface === 0;\n\nfunction getDevices(): Array<*> {\n  // $FlowFixMe\n  return HID.devices(ledgerUSBVendorId, 0x0).filter(filterInterface);\n}\n\nconst isDisconnectedError = e =>\n  e && e.message && e.message.indexOf(\"HID\") >= 0;\n\n/**\n * node-hid Transport minimal implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid-noevents\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHidNoEvents extends Transport<?string> {\n  /**\n   *\n   */\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof HID.HID === \"function\");\n\n  /**\n   *\n   */\n  static list = (): Promise<(?string)[]> =>\n    Promise.resolve(getDevices().map(d => d.path));\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<?string>>\n  ): Subscription => {\n    getDevices().forEach(device => {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device.path,\n        deviceModel,\n        device\n      });\n    });\n    observer.complete();\n    return { unsubscribe: () => {} };\n  };\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static async open(path: ?string) {\n    if (path) {\n      return Promise.resolve(new TransportNodeHidNoEvents(new HID.HID(path)));\n    }\n    const device = getDevices()[0];\n    if (!device) throw new TransportError(\"NoDevice\", \"NoDevice\");\n    return Promise.resolve(\n      new TransportNodeHidNoEvents(new HID.HID(device.path))\n    );\n  }\n\n  device: HID.HID;\n  deviceModel: ?DeviceModel;\n\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  disconnected = false;\n\n  constructor(device: HID.HID) {\n    super();\n    this.device = device;\n    const info = device.getDeviceInfo();\n    this.deviceModel =\n      info && info.serialNumber\n        ? identifyUSBProductId(parseInt(info.serialNumber, 16))\n        : null;\n  }\n\n  setDisconnected = () => {\n    if (!this.disconnected) {\n      this.emit(\"disconnect\");\n      this.disconnected = true;\n    }\n  };\n\n  writeHID = (content: Buffer): Promise<void> => {\n    const data = [0x00];\n    for (let i = 0; i < content.length; i++) {\n      data.push(content[i]);\n    }\n    try {\n      this.device.write(data);\n      return Promise.resolve();\n    } catch (e) {\n      if (isDisconnectedError(e)) {\n        this.setDisconnected();\n        return Promise.reject(new DisconnectedDevice(e.message));\n      }\n      return Promise.reject(e);\n    }\n  };\n\n  readHID = (): Promise<Buffer> =>\n    new Promise((resolve, reject) =>\n      this.device.read((e, res) => {\n        if (!res) {\n          return reject(new DisconnectedDevice());\n        }\n        if (e) {\n          if (isDisconnectedError(e)) {\n            this.setDisconnected();\n            return reject(new DisconnectedDevice(e.message));\n          }\n          reject(e);\n        } else {\n          const buffer = Buffer.from(res);\n          resolve(buffer);\n        }\n      })\n    );\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { debug, channel, packetSize } = this;\n      if (debug) {\n        debug(\"=>\" + apdu.toString(\"hex\"));\n      }\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.writeHID(blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.readHID();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      if (debug) {\n        debug(\"<=\" + result.toString(\"hex\"));\n      }\n      return result;\n    });\n\n  setScrambleKey() {}\n\n  /**\n   * release the USB device.\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.close();\n  }\n}\n"]}