{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["configurationValue","interfaceNumber","endpointNumber","TransportWebUSB","device","deviceModel","productId","exchangeBusyPromise","releaseInterface","reset","close","open","devices","length","configuration","selectConfiguration","claimInterface","message","transport","onDisconnect","e","navigator","usb","removeEventListener","_emitDisconnect","addEventListener","isSupported","list","listen","observer","unsubscribed","then","next","type","descriptor","complete","error","unsubscribe","channel","Math","floor","random","packetSize","_disconnectEmitted","emit","exchange","apdu","exchangeAtomicImpl","debug","toString","framing","blocks","makeBlocks","i","transferOut","result","acc","getReducedResult","transferIn","r","reduceResponse","Buffer","from","data","buffer","catch","includes"],"mappings":"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","file":"TransportWebUSB.js","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst interfaceNumber = 2;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: USBDevice) {\n    super();\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      device => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      error => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await device.reset();\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device);\n    const onDisconnect = e => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(interfaceNumber);\n    await this.device.reset();\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { debug, channel, packetSize } = this;\n      if (debug) {\n        debug(\"=>\" + apdu.toString(\"hex\"));\n      }\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        acc = framing.reduceResponse(acc, Buffer.from(r.data.buffer));\n      }\n\n      if (debug) {\n        debug(\"<=\" + result.toString(\"hex\"));\n      }\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n"]}